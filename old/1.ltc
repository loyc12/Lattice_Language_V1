NAMING IDEAS : LATTICE ( .ltc ), CLAUSE ( .cl )


// TODO : elaborate on comptime vs runtime
//  > Add distinct phases for each, so comptime is explicit

// TODO : review design tension :
//  > Open scopes vs explicitness
//  > Lifetime enforcement for captures
//  > Functions without explicit returns ( use _ ? )


// NOTE : possible avenues of expansion :
//  > Define a canonical Control Flow Graph (CFG)
//  > Add structs / class-lite
//  > Add optional memory tags
//  ... position : Vec2 *frame;
//  ... mesh     : Mesh *static;
//  ... scratch  : Buffer *temp;
//  > Add memory region ordering and tagging
//  ... in order to optionally specify what depends on what lifetime-wise
//  > Add batch execution / vectorised operation ( for explicit parallel processing )


============================================================
                    LANGUAGE OVERVIEW
============================================================

=== MENTAL MODEL ====

This language is built around three explicit questions:

1 - Who owns the value?
2 - Who is allowed to mutate it?
3 - When is code allowed to access external state?

By default, all values are locally owned and immutable.
Nothing is shared unless explicitly stated as such via referencing.

Values and references are distinct:
- values own data directly
- references alias existing data from an upstream scope

Mutability is explicit and never implicit:
- immutable variables cannot be change
- mutable variables change only with visible consent

Functions and procedures never access external state implicitly.
Any interaction with outer context must be:
- passed as a referenced parameter
- or captured explicitly at declaration time, via capturing

If a piece of code can mutate something, that fact is visible at both the declaration site and the call site.

The goal is local reasoning : if you understand a method’s signature, you understand its effects.



======== CHEATSHEET ========

==== VALUE AND REFERENCE QUALIFIERS ====

> Type    : immutable value
            - locally scoped
            - cannot reassign the variable
            - cannot mutate the value
            - passed to methods as an immutable copy by default
            - may be passed downstream by creating a reference ( *Type )

> &Type   : mutable value          // NOTE : is this too ambiguous for mainstream usuage ?
            - locally scoped
            - may reassign the variable
            - may mutate the value
            - may be passed downstream by creating a reference ( *&Type )

// NOTE   : &Type passed by value creates a new owned mutable instance in the callee
//          - No aliasing with the caller exists unless a reference (* or *&) is passed


> *Type   : immutable reference binding   ( read-only )
            - aliases an existing upstream variable
            - cannot rebind the reference
            - cannot mutate the referenced value
            - passed to methods as an alias, not a copy

> *&Type  : mutable reference binding     ( read-write )
            - aliases an existing upstream variable
            - cannot rebind the reference
            - may mutate the referenced value
            - passed to methods as an alias, not a copy


// NOTE : Mutability does not imply sharing. Only references (*) imply sharing.

// NOTE : Type qualifiers can be downgraded when passed as arguments to methods that require a lower permissibility one
// Permissibility ordering : TYPE < &TYPE < *TYPE < *&TYPE
// TODO : Figure out explicit downcasting syntax ( or do we just use the parameter qualifiers ? )


==== CALLABLE CONSTRUCTS ====

> Func  : function
          - explicit inputs and outputs
          - closed execution scope
          - may only mutate explicitly passed or captured mutable values
          - declaration   => foo : Func = foo[ args : Types ]{ body }
          - usage         => foo[ args ]

> Proc  : procedure
          - behave like functions
          - may also executes a provided continuation via "@exec(*)"
          - continuation runs in caller context
          - declaration   => foo : Proc = foo[ args : Types ](*){ body }
          - usage         => foo[ args ]( continuation body )

> @foo  : builtin callable
          - language-defined function or procedure
          - not user-definable
          - follows the same calling and mutability rules as functions or procedures
          - examples      => @return[], @ifEq[]()


==== IDENTIFIERS AND BINDING ====

> bar   : local binding
          - scoped to the current block

> #bar  : builtin identifier
          - language-defined keyword or sentinel value
          - not user-definable
          - examples      => #pi, #main, #true, #undef




======== BASIC DEFINITIONS ========

==== TYPES, VALUES, AND REFERENCES ====

// NOTE : Standalone identifiers with initial capitalization are treated as types


// Type   : immutable value type
// &Type  : mutable value type
// *Type  : immutable reference type
// *&Type : mutable reference type


// Values own their data.
// References alias existing data.
// Mutability and aliasing are independent and always explicit.

// Passing a value transfers ownership via copy.
// Passing a reference transfers access without transferring ownership.

// References cannot outlive the value they alias.
// Creating a reference to a shorter-lived value is illegal.



==== BUILTIN AND SPECIAL IDENTIFIERS ====


// "@foo" : builtin callable ( function or procedure )
//          - provided by the compiler or runtime
//          - obeys the same mutability, scoping, and calling rules as user-defined methods
//          - examples : @mod[], @lerp[], @ifEq[]()


// "#bar" : special identifier with reserved meaning
//          - not user-definable
//          - used to avoid namespace collision
//          - examples : #main, #undef, #true, #false, #PI



==== DEFERRED COMPUTATIONS ====     // TODO : make sure value returning fits with methods' style


// "$Type()" : deferred computation
//             - a runtime value representing delayed evaluation
//             - declared via "$Type( body )"
//             - captures all referenced variables as immutable references
//             - captured bindings are read-only inside the deferred computation
//             - does not execute when declared
//             - may be evaluated, passed downstream, or discarded
//             - cannot mutate external state
//             - declared as a method parameter via "[ expr : $Type ]"


// @eval( expr ) : evaluates a deferred computation
//              - produces a value
//              - has no side effects
//              - shorthand : "$expr" when passed as a method parameter
//              - shorthand is not valid in other contexts



==== EXECUTION MODEL ====       // MAYBE : add comptime function and allow their calls during compile-time


// Execution is single-threaded and deterministic
// Code executes in declaration order unless altered explicitly
// Method calls are synchronous
// There is no implicit concurrency or parallelism


// The language distinguishes between:
// - compile-time structure   ( method declarations, captures, deferred computations )
// - runtime execution        ( method calls, mutation, control flow )


// "compile-time" refers to the phase where:
// - method bodies are fixed
// - captures are resolved
// - deferred computations are constructed


// "runtime" refers to the phase where:
// - methods are called
// - mutable state is modified
// - deferred computations are evaluated



==== SCOPING RULES ====


// [] : declaration scope
//      - used to declare method parameters
//      - used to declare capture lists
//      - evaluated at compile-time


// {} : closed scope
//      - forms a distinct local execution context
//      - cannot access external bindings unless passed or captured
//      - local bindings exist only for the duration of execution
//      - structure is immutable once declared


// () : open scope
//      - shares the surrounding execution context
//      - may access and mutate surrounding bindings
//      - structure is immutable once declared
//      - execution may be deferred ( continuations )


// *  : reference creation
//      - produces an alias to an existing binding
//      - does not create ownership
//      - reference mutability must be explicitly specified ( *Type vs *&Type )



==== METHODS ====


// "Method" refers to either a function or a procedure

// Methods do not return values implicitly.
// All observable effects occur exclusively through:
// - mutable references
// - mutable captures
// - control flow ( procedures )


// MAYBE : add a way to return a single value for ease of use, and standardise it with defer computation


// Func : function
//        - has a closed scope body
//        - cannot access external context unless explicitly captured
//        - produces side effects only through:
//          - mutable reference parameters
//          - mutable runtime captures

// Declaration => foo : Func = [ args : Types ]{ body };
// Usage       => foo[ args ];


// Proc : procedure
//        - similar to functions
//        - additionally supports an attached continuation
//        - continuation is an open scope
//        - continuation executes only when explicitly invoked via "@exec(*)"

// Declaration => foo : Proc = [ args : Types ](*){ body };
// Usage       => foo[ args ]( continuation body );


// Continuations are open scopes attached at call time
// They execute in the caller’s context
// They may read and mutate caller-local bindings


// @exec(*) : executes the attached continuation
//            - valid only inside procedures
//            - may be called zero or more times
//            - execution resumes in the procedure after the continuation returns



==== CAPTURING ====


// Capturing binds external variables at method declaration time
// Captures are specified in a method's second declaration scope


foo : Func = [ args : Types ]{ body }                     // non-capturing
foo : Func = [ args : Types ][ capturedVars ]{ body }     // capturing


// Captured variables must exist in the declaration context
// Their types are known and therefore omitted
// Captures are resolved at compile-time
// Captured methods are called like standard ones
// Captured variables are never supplied at call time


// Comptime capture : [ capturedVar ]
//                    - used to specialize code structure ( templating )
//                    - capturedVar is replaced by its compile-time value
//                    - the value is embedded directly into the method body
//                    - no runtime aliasing occurs
//                    - captured values are immutable
//                    - mutable comptime capture is illegal

// MAYBE : readd [ &capturedVar ]


// Runtime capture  : [ *capturedVar ] / [ *&capturedVar ]
//                    - capturedVar becomes a reference to the original binding
//                    - mutation, if allowed, affects the original variable
//                    - enables shared state across methods and scopes
//                    - avoids explicit state threading at every call site


// Lifetime rule :
// A variable may be captured only if its lifetime exceeds that of the method.
// Capturing a variable that may go out of scope before method execution is illegal.


// OPEN DESIGN QUESTION :
// - Should escape analysis or heap promotion relax this rule?
// - If so, under what guarantees?




==== BUILTINS ====  ( non-exhaustive )


// @return[] : exits the current closed scope immediately
//             - does not return a value


// @repeat[] : exits and re-enters the current closed scope
//             - restarts execution with a fresh local context
//             - mutable parameters and captured references are preserved
//             - side effects performed before @repeat[] are not rolled back



============================================================
                  CODE SNIPPETS EXAMPLE
============================================================


==== SIMPLE ADDITION VIA EXPLICIT MUTABLE OUTPUT ====


// Function returning its result via a mutable output parameter

add : Func = [ ret : *&Int, a : Int, b : Int ]
{
  ret = a + b;
};


// Initial values

val1 : Int  = 1;
val2 : Int  = 1;
sum  : &Int = #undef;


// Explicitly pass mutable output variable

add[ *&sum, val1, val2 ];


// Immutable value passed to builtin output routine

@printInt[ sum ];



==== EXAMPLE BUILT-IN IMPLEMENTATIONS ====


// Conditional execution via deferred boolean and continuation

ifTrue : Proc = [ cond : $Bool ](*)
{
  @ifEq[ $cond, #true ]
  (
    @exec(*);
  );
};


// Looping construct built from conditional execution and repetition

whileTrue : Proc = [ cond : $Bool ](*)
{
  ifTrue[ cond ]
  (
    @exec(*);
    @repeat[];
  );
};



==== FIBONACCI SEQUENCE PRINTING ====


// Advances the Fibonacci state and emits the next value

increment : Func = [ prev : *&Int, res : *&Int ]
{
  tmp : &Int = res;

  add[ &res, prev, res ];

  prev = tmp;

  @printInt[ res ];
};


// Initial state

sum  : &Int = #undef;
val1 : &Int = 1;

fibLimit : Int = 100;


// Loop controlled by a deferred condition evaluated each iteration

whileTrue[ $Bool( sum <= fibLimit ) ]
(
  increment[ *&val1, *&sum ];
);



==== FULL PROGRAM EXAMPLE ====


// Program entrypoint declaration

#main = comparator;


// Prints all integers exclusively between two distinct values

comparator : Func = [ arg1 : Int, arg2 : Int ]
{
  @ifTrue[ $Bool( arg1 == arg2 )]
  (
    @printString[ "usage : comparator [ value1 ] [ value2 ]\n" ];
    @printString[ " note : values must differ\n" ];

    @return[];
  );

  @printString[ "printing range :\n" ];

  min  : Int = @min[ arg1, arg2 ];
  max  : Int = @max[ arg1, arg2 ];

  diff : &Int = max - min;
  diff        = diff - 1;

  @whileTrue[ $Bool( diff != 0 ) ]
  (
    @print[ max - diff ];
    diff = diff - 1;
  );
};



==== CAPTURING AND FUNCTION GENERATION ====

// Simple immutable capture

incrementValue : Int = 3;

valueIncrementer : Func = [ *&val : Int ][ incrementValue ]
{
  val = val + incrementValue;      // will compile to "val = val + 3;"
};


// Simple mutable capture

counter : &Int = 0;

valueCounter : Func = [ val : Int ][ &counter ]
{
  counter = counter + val;
};



// Function generation using immutable capture

generateValueIncrementer : Func = [ f : &Func, inc : Int ]
{
  f = [ val : Int, ret : &Int ][ inc ]
  {
    ret = val + inc;
  };
};



// Function generation using mutable capture of shared local state

generateSharedCounter : Func = [ f : &Func ]
{
  sharedCounter : &Int = 0;

  f = [ val : Int, ret : &Int ][ &sharedCounter ]
  {
    sharedCounter = sharedCounter + val;
    ret = sharedVal;
  };
};



// Function generation using nested mutable capture of shared external state

generateGlobalCounter : Func = [ f : &Func ][ &globalCounter ]
{
  f = [ val : Int, ret : &Int ][ &globalCounter ]
  {
    globalCounter = globalCounter + val;
    ret = globalCounter;
  };
};
